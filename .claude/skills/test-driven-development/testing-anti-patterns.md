# テストのアンチパターン

**このリファレンスを読むタイミング:** テストの作成・変更時、モックの追加時、プロダクションコードにテスト専用メソッドを追加したくなった時。

## 概要

テストは実際の動作を検証すべきであり、モックの動作を検証してはならない。モックは分離のための手段であり、テスト対象ではない。

**基本原則:** コードが何をするかをテストする。モックが何をするかではない。

**厳密な TDD に従えば、これらのアンチパターンは防げる。**

## 鉄の掟

```
1. モックの動作をテストしてはならない
2. プロダクションクラスにテスト専用メソッドを追加してはならない
3. 依存関係を理解せずにモックしてはならない
```

## アンチパターン 1: モックの動作をテストする

**違反:**
```typescript
// ❌ BAD: モックの存在をテストしている
test('サイドバーを描画する', () => {
  render(<Page />);
  expect(screen.getByTestId('sidebar-mock')).toBeInTheDocument();
});
```

**なぜ間違いか:**
- コンポーネントではなくモックが動作することを検証している
- モックがあればテストが通り、なければ失敗する
- 実際の動作について何も教えてくれない

**人間のパートナーの指摘:** 「モックの動作をテストしていないか？」

**修正:**
```typescript
// ✅ GOOD: 本物のコンポーネントをテストするか、モックしない
test('サイドバーを描画する', () => {
  render(<Page />);  // サイドバーをモックしない
  expect(screen.getByRole('navigation')).toBeInTheDocument();
});

// または分離のためにサイドバーをモックする必要がある場合:
// モックに対してアサートしない — サイドバーが存在する状態での Page の動作をテストする
```

### ゲート関数

```
モック要素に対してアサートする前に:
  問う: 「実際のコンポーネントの動作をテストしているか、モックの存在をテストしているだけか？」

  モックの存在をテストしている場合:
    止まる - アサーションを削除するか、コンポーネントのモックを外す

  代わりに実際の動作をテストする
```

## アンチパターン 2: プロダクションにテスト専用メソッド

**違反:**
```typescript
// ❌ BAD: destroy() はテストでしか使われない
class Session {
  async destroy() {  // プロダクション API に見える！
    await this._workspaceManager?.destroyWorkspace(this.id);
    // ... クリーンアップ
  }
}

// テスト内
afterEach(() => session.destroy());
```

**なぜ間違いか:**
- プロダクションクラスがテスト専用コードで汚染される
- 本番で誤って呼ばれると危険
- YAGNI と関心の分離に違反
- オブジェクトのライフサイクルとエンティティのライフサイクルを混同

**修正:**
```typescript
// ✅ GOOD: テストユーティリティがテスト用クリーンアップを処理する
// Session に destroy() はない — 本番ではステートレス

// test-utils/ 内
export async function cleanupSession(session: Session) {
  const workspace = session.getWorkspaceInfo();
  if (workspace) {
    await workspaceManager.destroyWorkspace(workspace.id);
  }
}

// テスト内
afterEach(() => cleanupSession(session));
```

### ゲート関数

```
プロダクションクラスにメソッドを追加する前に:
  問う: 「テストでしか使われないか？」

  はいの場合:
    止まる - 追加しない
    テストユーティリティに配置する

  問う: 「このクラスがこのリソースのライフサイクルを管理すべきか？」

  いいえの場合:
    止まる - このメソッドを置くクラスが間違い
```

## アンチパターン 3: 理解なきモック

**違反:**
```typescript
// ❌ BAD: モックがテストロジックを壊す
test('重複サーバーを検出する', () => {
  // モックがテストの依存する設定書き込みを阻止！
  vi.mock('ToolCatalog', () => ({
    discoverAndCacheTools: vi.fn().mockResolvedValue(undefined)
  }));

  await addServer(config);
  await addServer(config);  // エラーを投げるべき — だが投げない！
});
```

**なぜ間違いか:**
- モックされたメソッドにテストが依存する副作用があった（設定の書き込み）
- 「安全のため」の過剰モックが実際の動作を壊す
- テストが間違った理由で通るか、不可解に失敗する

**修正:**
```typescript
// ✅ GOOD: 正しいレベルでモックする
test('重複サーバーを検出する', () => {
  // 遅い部分だけモックし、テストに必要な動作は保持
  vi.mock('MCPServerManager'); // 遅いサーバー起動だけモック

  await addServer(config);  // 設定が書き込まれる
  await addServer(config);  // 重複が検出される ✓
});
```

### ゲート関数

```
メソッドをモックする前に:
  止まる - まだモックしない

  1. 問う: 「本物のメソッドにはどんな副作用があるか？」
  2. 問う: 「このテストはその副作用に依存しているか？」
  3. 問う: 「このテストが何を必要としているか完全に理解しているか？」

  副作用に依存している場合:
    より低いレベルでモックする（実際に遅い/外部の操作）
    または必要な動作を保持するテストダブルを使用する
    テストが依存する高レベルメソッドをモックしない

  テストが何を必要としているか不明な場合:
    まず本物の実装でテストを実行する
    実際に何が起こる必要があるか観察する
    その後、正しいレベルで最小限のモックを追加する

  危険信号:
    - 「安全のためにモックしておこう」
    - 「遅いかもしれないのでモックしよう」
    - 依存関係の連鎖を理解せずにモックしている
```

## アンチパターン 4: 不完全なモック

**違反:**
```typescript
// ❌ BAD: 部分的なモック — 必要だと思ったフィールドだけ
const mockResponse = {
  status: 'success',
  data: { userId: '123', name: 'Alice' }
  // 欠落: 下流コードが使用する metadata
};

// 後で: コードが response.metadata.requestId にアクセスして壊れる
```

**なぜ間違いか:**
- **部分的なモックは構造的前提を隠す** — 知っているフィールドだけモックしている
- **下流コードが含めなかったフィールドに依存するかもしれない** — サイレントな失敗
- **テストは通るが結合テストで失敗** — モックは不完全、本物の API は完全
- **偽りの自信** — テストが実際の動作について何も証明しない

**鉄の掟:** 実際に存在する通りの完全なデータ構造をモックする。直接テストが使うフィールドだけではない。

**修正:**
```typescript
// ✅ GOOD: 実際の API の完全性を反映する
const mockResponse = {
  status: 'success',
  data: { userId: '123', name: 'Alice' },
  metadata: { requestId: 'req-789', timestamp: 1234567890 }
  // 本物の API が返すすべてのフィールド
};
```

### ゲート関数

```
モックレスポンスを作成する前に:
  確認: 「本物の API レスポンスにはどんなフィールドが含まれるか？」

  アクション:
    1. ドキュメントや例から実際の API レスポンスを調べる
    2. システムが下流で消費する可能性のあるすべてのフィールドを含める
    3. モックが本物のレスポンスのスキーマと完全に一致することを検証する

  重要:
    モックを作成するなら、構造全体を理解しなければならない
    部分的なモックは、省略されたフィールドにコードが依存するとサイレントに失敗する

  不明な場合: ドキュメントに記載されたすべてのフィールドを含める
```

## アンチパターン 5: 後回しの統合テスト

**違反:**
```
✅ 実装完了
❌ テスト未作成
「テスト準備完了」
```

**なぜ間違いか:**
- テストは実装の一部であり、オプションのフォローアップではない
- TDD なら検出できた
- テストなしに完了とは言えない

**修正:**
```
TDD サイクル:
1. 失敗するテストを書く
2. テストを通すよう実装する
3. リファクタリング
4. その後初めて完了と宣言
```

## モックが複雑になりすぎた時

**警告サイン:**
- モックのセットアップがテストロジックより長い
- テストを通すためにすべてをモックしている
- モックに本物のコンポーネントが持つメソッドが欠けている
- モックの変更でテストが壊れる

**人間のパートナーの問い:** 「ここでモックを使う必要があるか？」

**検討:** 本物のコンポーネントを使った統合テストの方が、複雑なモックよりシンプルな場合が多い

## TDD がこれらのアンチパターンを防ぐ理由

**TDD が助ける理由:**
1. **テストを先に書く** → 実際に何をテストしているか考えることを強制する
2. **失敗を見届ける** → テストがモックではなく実際の動作をテストしていることを確認
3. **最小限の実装** → テスト専用メソッドが忍び込まない
4. **本物の依存関係** → モックする前にテストが実際に何を必要とするか見える

**モックの動作をテストしているなら、TDD に違反している** — 本物のコードに対してテストが失敗するのを見る前にモックを追加した。

## クイックリファレンス

| アンチパターン | 修正 |
|---------------|------|
| モック要素に対するアサート | 本物のコンポーネントをテストするか、モックを外す |
| プロダクションのテスト専用メソッド | テストユーティリティに移動 |
| 理解なきモック | まず依存関係を理解し、最小限にモック |
| 不完全なモック | 本物の API を完全に反映 |
| 後回しのテスト | TDD — テストが先 |
| 過剰に複雑なモック | 統合テストを検討 |

## 危険信号

- `*-mock` テスト ID に対するアサーション
- テストファイルでしか呼ばれないメソッド
- モックのセットアップがテストの 50% 以上
- モックを除去するとテストが失敗する
- なぜモックが必要か説明できない
- 「安全のために」モックしている

## 結論

**モックは分離のためのツールであり、テスト対象ではない。**

TDD がモックの動作をテストしていることを明らかにしたら、間違った方向に進んでいる。

修正: 実際の動作をテストするか、そもそもなぜモックしているか問い直す。
